// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/client_login.proto

#ifndef PROTOBUF_proto_2fclient_5flogin_2eproto__INCLUDED
#define PROTOBUF_proto_2fclient_5flogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace cli {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

class SignUpReq;
class SignUpRsp;
class SignInReq;
class SignInRsp;
class QueryPartitionReq;
class QueryPartitionRsp;
class QueryPartitionRsp_Partition;
class EntryPartitionReq;
class EntryPartitionRsp;

enum QueryPartitionRsp_StateType {
  QueryPartitionRsp_StateType_kNormal = 0,
  QueryPartitionRsp_StateType_kShutdown = 1
};
bool QueryPartitionRsp_StateType_IsValid(int value);
const QueryPartitionRsp_StateType QueryPartitionRsp_StateType_StateType_MIN = QueryPartitionRsp_StateType_kNormal;
const QueryPartitionRsp_StateType QueryPartitionRsp_StateType_StateType_MAX = QueryPartitionRsp_StateType_kShutdown;
const int QueryPartitionRsp_StateType_StateType_ARRAYSIZE = QueryPartitionRsp_StateType_StateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryPartitionRsp_StateType_descriptor();
inline const ::std::string& QueryPartitionRsp_StateType_Name(QueryPartitionRsp_StateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryPartitionRsp_StateType_descriptor(), value);
}
inline bool QueryPartitionRsp_StateType_Parse(
    const ::std::string& name, QueryPartitionRsp_StateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryPartitionRsp_StateType>(
    QueryPartitionRsp_StateType_descriptor(), name, value);
}
// ===================================================================

class SignUpReq : public ::google::protobuf::Message {
 public:
  SignUpReq();
  virtual ~SignUpReq();

  SignUpReq(const SignUpReq& from);

  inline SignUpReq& operator=(const SignUpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignUpReq& default_instance();

  void Swap(SignUpReq* other);

  // implements Message ----------------------------------------------

  SignUpReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignUpReq& from);
  void MergeFrom(const SignUpReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional string platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string os = 4;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 4;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string model = 5;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 5;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string deviceid = 6;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 6;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:cli.SignUpReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_;
  ::std::string* passwd_;
  ::std::string* platform_;
  ::std::string* os_;
  ::std::string* model_;
  ::std::string* deviceid_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static SignUpReq* default_instance_;
};
// -------------------------------------------------------------------

class SignUpRsp : public ::google::protobuf::Message {
 public:
  SignUpRsp();
  virtual ~SignUpRsp();

  SignUpRsp(const SignUpRsp& from);

  inline SignUpRsp& operator=(const SignUpRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignUpRsp& default_instance();

  void Swap(SignUpRsp* other);

  // implements Message ----------------------------------------------

  SignUpRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignUpRsp& from);
  void MergeFrom(const SignUpRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cli.SignUpRsp)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static SignUpRsp* default_instance_;
};
// -------------------------------------------------------------------

class SignInReq : public ::google::protobuf::Message {
 public:
  SignInReq();
  virtual ~SignInReq();

  SignInReq(const SignInReq& from);

  inline SignInReq& operator=(const SignInReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignInReq& default_instance();

  void Swap(SignInReq* other);

  // implements Message ----------------------------------------------

  SignInReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignInReq& from);
  void MergeFrom(const SignInReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional string deviceid = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:cli.SignInReq)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_;
  ::std::string* passwd_;
  ::std::string* deviceid_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static SignInReq* default_instance_;
};
// -------------------------------------------------------------------

class SignInRsp : public ::google::protobuf::Message {
 public:
  SignInRsp();
  virtual ~SignInRsp();

  SignInRsp(const SignInRsp& from);

  inline SignInRsp& operator=(const SignInRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignInRsp& default_instance();

  void Swap(SignInRsp* other);

  // implements Message ----------------------------------------------

  SignInRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignInRsp& from);
  void MergeFrom(const SignInRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cli.SignInRsp)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static SignInRsp* default_instance_;
};
// -------------------------------------------------------------------

class QueryPartitionReq : public ::google::protobuf::Message {
 public:
  QueryPartitionReq();
  virtual ~QueryPartitionReq();

  QueryPartitionReq(const QueryPartitionReq& from);

  inline QueryPartitionReq& operator=(const QueryPartitionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPartitionReq& default_instance();

  void Swap(QueryPartitionReq* other);

  // implements Message ----------------------------------------------

  QueryPartitionReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPartitionReq& from);
  void MergeFrom(const QueryPartitionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cli.QueryPartitionReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static QueryPartitionReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryPartitionRsp_Partition : public ::google::protobuf::Message {
 public:
  QueryPartitionRsp_Partition();
  virtual ~QueryPartitionRsp_Partition();

  QueryPartitionRsp_Partition(const QueryPartitionRsp_Partition& from);

  inline QueryPartitionRsp_Partition& operator=(const QueryPartitionRsp_Partition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPartitionRsp_Partition& default_instance();

  void Swap(QueryPartitionRsp_Partition* other);

  // implements Message ----------------------------------------------

  QueryPartitionRsp_Partition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPartitionRsp_Partition& from);
  void MergeFrom(const QueryPartitionRsp_Partition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .cli.QueryPartitionRsp.StateType status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::cli::QueryPartitionRsp_StateType status() const;
  inline void set_status(::cli::QueryPartitionRsp_StateType value);

  // required bool is_recommend = 4;
  inline bool has_is_recommend() const;
  inline void clear_is_recommend();
  static const int kIsRecommendFieldNumber = 4;
  inline bool is_recommend() const;
  inline void set_is_recommend(bool value);

  // @@protoc_insertion_point(class_scope:cli.QueryPartitionRsp.Partition)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_recommend();
  inline void clear_has_is_recommend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  int status_;
  bool is_recommend_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static QueryPartitionRsp_Partition* default_instance_;
};
// -------------------------------------------------------------------

class QueryPartitionRsp : public ::google::protobuf::Message {
 public:
  QueryPartitionRsp();
  virtual ~QueryPartitionRsp();

  QueryPartitionRsp(const QueryPartitionRsp& from);

  inline QueryPartitionRsp& operator=(const QueryPartitionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryPartitionRsp& default_instance();

  void Swap(QueryPartitionRsp* other);

  // implements Message ----------------------------------------------

  QueryPartitionRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryPartitionRsp& from);
  void MergeFrom(const QueryPartitionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef QueryPartitionRsp_Partition Partition;

  typedef QueryPartitionRsp_StateType StateType;
  static const StateType kNormal = QueryPartitionRsp_StateType_kNormal;
  static const StateType kShutdown = QueryPartitionRsp_StateType_kShutdown;
  static inline bool StateType_IsValid(int value) {
    return QueryPartitionRsp_StateType_IsValid(value);
  }
  static const StateType StateType_MIN =
    QueryPartitionRsp_StateType_StateType_MIN;
  static const StateType StateType_MAX =
    QueryPartitionRsp_StateType_StateType_MAX;
  static const int StateType_ARRAYSIZE =
    QueryPartitionRsp_StateType_StateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StateType_descriptor() {
    return QueryPartitionRsp_StateType_descriptor();
  }
  static inline const ::std::string& StateType_Name(StateType value) {
    return QueryPartitionRsp_StateType_Name(value);
  }
  static inline bool StateType_Parse(const ::std::string& name,
      StateType* value) {
    return QueryPartitionRsp_StateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .cli.QueryPartitionRsp.Partition lists = 1;
  inline int lists_size() const;
  inline void clear_lists();
  static const int kListsFieldNumber = 1;
  inline const ::cli::QueryPartitionRsp_Partition& lists(int index) const;
  inline ::cli::QueryPartitionRsp_Partition* mutable_lists(int index);
  inline ::cli::QueryPartitionRsp_Partition* add_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::cli::QueryPartitionRsp_Partition >&
      lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::cli::QueryPartitionRsp_Partition >*
      mutable_lists();

  // @@protoc_insertion_point(class_scope:cli.QueryPartitionRsp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cli::QueryPartitionRsp_Partition > lists_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static QueryPartitionRsp* default_instance_;
};
// -------------------------------------------------------------------

class EntryPartitionReq : public ::google::protobuf::Message {
 public:
  EntryPartitionReq();
  virtual ~EntryPartitionReq();

  EntryPartitionReq(const EntryPartitionReq& from);

  inline EntryPartitionReq& operator=(const EntryPartitionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntryPartitionReq& default_instance();

  void Swap(EntryPartitionReq* other);

  // implements Message ----------------------------------------------

  EntryPartitionReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntryPartitionReq& from);
  void MergeFrom(const EntryPartitionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cli.EntryPartitionReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static EntryPartitionReq* default_instance_;
};
// -------------------------------------------------------------------

class EntryPartitionRsp : public ::google::protobuf::Message {
 public:
  EntryPartitionRsp();
  virtual ~EntryPartitionRsp();

  EntryPartitionRsp(const EntryPartitionRsp& from);

  inline EntryPartitionRsp& operator=(const EntryPartitionRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntryPartitionRsp& default_instance();

  void Swap(EntryPartitionRsp* other);

  // implements Message ----------------------------------------------

  EntryPartitionRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntryPartitionRsp& from);
  void MergeFrom(const EntryPartitionRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint64 token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cli.EntryPartitionRsp)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint64 token_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_AssignDesc_proto_2fclient_5flogin_2eproto();
  friend void protobuf_ShutdownFile_proto_2fclient_5flogin_2eproto();

  void InitAsDefaultInstance();
  static EntryPartitionRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// SignUpReq

// required string user = 1;
inline bool SignUpReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignUpReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignUpReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignUpReq::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& SignUpReq::user() const {
  // @@protoc_insertion_point(field_get:cli.SignUpReq.user)
  return *user_;
}
inline void SignUpReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignUpReq.user)
}
inline void SignUpReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignUpReq.user)
}
inline void SignUpReq::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignUpReq.user)
}
inline ::std::string* SignUpReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignUpReq.user)
  return user_;
}
inline ::std::string* SignUpReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignUpReq::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignUpReq.user)
}

// required string passwd = 2;
inline bool SignUpReq::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignUpReq::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignUpReq::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignUpReq::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& SignUpReq::passwd() const {
  // @@protoc_insertion_point(field_get:cli.SignUpReq.passwd)
  return *passwd_;
}
inline void SignUpReq::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignUpReq.passwd)
}
inline void SignUpReq::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignUpReq.passwd)
}
inline void SignUpReq::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignUpReq.passwd)
}
inline ::std::string* SignUpReq::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignUpReq.passwd)
  return passwd_;
}
inline ::std::string* SignUpReq::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignUpReq::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignUpReq.passwd)
}

// optional string platform = 3;
inline bool SignUpReq::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignUpReq::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignUpReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignUpReq::clear_platform() {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& SignUpReq::platform() const {
  // @@protoc_insertion_point(field_get:cli.SignUpReq.platform)
  return *platform_;
}
inline void SignUpReq::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignUpReq.platform)
}
inline void SignUpReq::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignUpReq.platform)
}
inline void SignUpReq::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignUpReq.platform)
}
inline ::std::string* SignUpReq::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignUpReq.platform)
  return platform_;
}
inline ::std::string* SignUpReq::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignUpReq::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignUpReq.platform)
}

// optional string os = 4;
inline bool SignUpReq::has_os() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignUpReq::set_has_os() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignUpReq::clear_has_os() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignUpReq::clear_os() {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& SignUpReq::os() const {
  // @@protoc_insertion_point(field_get:cli.SignUpReq.os)
  return *os_;
}
inline void SignUpReq::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignUpReq.os)
}
inline void SignUpReq::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignUpReq.os)
}
inline void SignUpReq::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignUpReq.os)
}
inline ::std::string* SignUpReq::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignUpReq.os)
  return os_;
}
inline ::std::string* SignUpReq::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignUpReq::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignUpReq.os)
}

// optional string model = 5;
inline bool SignUpReq::has_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignUpReq::set_has_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignUpReq::clear_has_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignUpReq::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& SignUpReq::model() const {
  // @@protoc_insertion_point(field_get:cli.SignUpReq.model)
  return *model_;
}
inline void SignUpReq::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignUpReq.model)
}
inline void SignUpReq::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignUpReq.model)
}
inline void SignUpReq::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignUpReq.model)
}
inline ::std::string* SignUpReq::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignUpReq.model)
  return model_;
}
inline ::std::string* SignUpReq::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignUpReq::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignUpReq.model)
}

// optional string deviceid = 6;
inline bool SignUpReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignUpReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignUpReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignUpReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& SignUpReq::deviceid() const {
  // @@protoc_insertion_point(field_get:cli.SignUpReq.deviceid)
  return *deviceid_;
}
inline void SignUpReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignUpReq.deviceid)
}
inline void SignUpReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignUpReq.deviceid)
}
inline void SignUpReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignUpReq.deviceid)
}
inline ::std::string* SignUpReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignUpReq.deviceid)
  return deviceid_;
}
inline ::std::string* SignUpReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignUpReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignUpReq.deviceid)
}

// -------------------------------------------------------------------

// SignUpRsp

// required uint32 id = 1;
inline bool SignUpRsp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignUpRsp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignUpRsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignUpRsp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SignUpRsp::id() const {
  // @@protoc_insertion_point(field_get:cli.SignUpRsp.id)
  return id_;
}
inline void SignUpRsp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cli.SignUpRsp.id)
}

// -------------------------------------------------------------------

// SignInReq

// required string user = 1;
inline bool SignInReq::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignInReq::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignInReq::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignInReq::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& SignInReq::user() const {
  // @@protoc_insertion_point(field_get:cli.SignInReq.user)
  return *user_;
}
inline void SignInReq::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignInReq.user)
}
inline void SignInReq::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignInReq.user)
}
inline void SignInReq::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignInReq.user)
}
inline ::std::string* SignInReq::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignInReq.user)
  return user_;
}
inline ::std::string* SignInReq::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignInReq::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignInReq.user)
}

// required string passwd = 2;
inline bool SignInReq::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignInReq::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignInReq::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignInReq::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& SignInReq::passwd() const {
  // @@protoc_insertion_point(field_get:cli.SignInReq.passwd)
  return *passwd_;
}
inline void SignInReq::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignInReq.passwd)
}
inline void SignInReq::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignInReq.passwd)
}
inline void SignInReq::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignInReq.passwd)
}
inline ::std::string* SignInReq::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    passwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignInReq.passwd)
  return passwd_;
}
inline ::std::string* SignInReq::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignInReq::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignInReq.passwd)
}

// optional string deviceid = 3;
inline bool SignInReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignInReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignInReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignInReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& SignInReq::deviceid() const {
  // @@protoc_insertion_point(field_get:cli.SignInReq.deviceid)
  return *deviceid_;
}
inline void SignInReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:cli.SignInReq.deviceid)
}
inline void SignInReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.SignInReq.deviceid)
}
inline void SignInReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.SignInReq.deviceid)
}
inline ::std::string* SignInReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.SignInReq.deviceid)
  return deviceid_;
}
inline ::std::string* SignInReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SignInReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.SignInReq.deviceid)
}

// -------------------------------------------------------------------

// SignInRsp

// required uint32 id = 1;
inline bool SignInRsp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignInRsp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignInRsp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignInRsp::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SignInRsp::id() const {
  // @@protoc_insertion_point(field_get:cli.SignInRsp.id)
  return id_;
}
inline void SignInRsp::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cli.SignInRsp.id)
}

// -------------------------------------------------------------------

// QueryPartitionReq

// -------------------------------------------------------------------

// QueryPartitionRsp_Partition

// required uint32 id = 1;
inline bool QueryPartitionRsp_Partition::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryPartitionRsp_Partition::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryPartitionRsp_Partition::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryPartitionRsp_Partition::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 QueryPartitionRsp_Partition::id() const {
  // @@protoc_insertion_point(field_get:cli.QueryPartitionRsp.Partition.id)
  return id_;
}
inline void QueryPartitionRsp_Partition::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cli.QueryPartitionRsp.Partition.id)
}

// required string name = 2;
inline bool QueryPartitionRsp_Partition::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryPartitionRsp_Partition::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryPartitionRsp_Partition::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryPartitionRsp_Partition::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QueryPartitionRsp_Partition::name() const {
  // @@protoc_insertion_point(field_get:cli.QueryPartitionRsp.Partition.name)
  return *name_;
}
inline void QueryPartitionRsp_Partition::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:cli.QueryPartitionRsp.Partition.name)
}
inline void QueryPartitionRsp_Partition::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.QueryPartitionRsp.Partition.name)
}
inline void QueryPartitionRsp_Partition::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.QueryPartitionRsp.Partition.name)
}
inline ::std::string* QueryPartitionRsp_Partition::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.QueryPartitionRsp.Partition.name)
  return name_;
}
inline ::std::string* QueryPartitionRsp_Partition::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QueryPartitionRsp_Partition::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.QueryPartitionRsp.Partition.name)
}

// required .cli.QueryPartitionRsp.StateType status = 3;
inline bool QueryPartitionRsp_Partition::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryPartitionRsp_Partition::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryPartitionRsp_Partition::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryPartitionRsp_Partition::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cli::QueryPartitionRsp_StateType QueryPartitionRsp_Partition::status() const {
  // @@protoc_insertion_point(field_get:cli.QueryPartitionRsp.Partition.status)
  return static_cast< ::cli::QueryPartitionRsp_StateType >(status_);
}
inline void QueryPartitionRsp_Partition::set_status(::cli::QueryPartitionRsp_StateType value) {
  assert(::cli::QueryPartitionRsp_StateType_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cli.QueryPartitionRsp.Partition.status)
}

// required bool is_recommend = 4;
inline bool QueryPartitionRsp_Partition::has_is_recommend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryPartitionRsp_Partition::set_has_is_recommend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryPartitionRsp_Partition::clear_has_is_recommend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryPartitionRsp_Partition::clear_is_recommend() {
  is_recommend_ = false;
  clear_has_is_recommend();
}
inline bool QueryPartitionRsp_Partition::is_recommend() const {
  // @@protoc_insertion_point(field_get:cli.QueryPartitionRsp.Partition.is_recommend)
  return is_recommend_;
}
inline void QueryPartitionRsp_Partition::set_is_recommend(bool value) {
  set_has_is_recommend();
  is_recommend_ = value;
  // @@protoc_insertion_point(field_set:cli.QueryPartitionRsp.Partition.is_recommend)
}

// -------------------------------------------------------------------

// QueryPartitionRsp

// repeated .cli.QueryPartitionRsp.Partition lists = 1;
inline int QueryPartitionRsp::lists_size() const {
  return lists_.size();
}
inline void QueryPartitionRsp::clear_lists() {
  lists_.Clear();
}
inline const ::cli::QueryPartitionRsp_Partition& QueryPartitionRsp::lists(int index) const {
  // @@protoc_insertion_point(field_get:cli.QueryPartitionRsp.lists)
  return lists_.Get(index);
}
inline ::cli::QueryPartitionRsp_Partition* QueryPartitionRsp::mutable_lists(int index) {
  // @@protoc_insertion_point(field_mutable:cli.QueryPartitionRsp.lists)
  return lists_.Mutable(index);
}
inline ::cli::QueryPartitionRsp_Partition* QueryPartitionRsp::add_lists() {
  // @@protoc_insertion_point(field_add:cli.QueryPartitionRsp.lists)
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cli::QueryPartitionRsp_Partition >&
QueryPartitionRsp::lists() const {
  // @@protoc_insertion_point(field_list:cli.QueryPartitionRsp.lists)
  return lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::cli::QueryPartitionRsp_Partition >*
QueryPartitionRsp::mutable_lists() {
  // @@protoc_insertion_point(field_mutable_list:cli.QueryPartitionRsp.lists)
  return &lists_;
}

// -------------------------------------------------------------------

// EntryPartitionReq

// required uint32 id = 1;
inline bool EntryPartitionReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntryPartitionReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntryPartitionReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntryPartitionReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 EntryPartitionReq::id() const {
  // @@protoc_insertion_point(field_get:cli.EntryPartitionReq.id)
  return id_;
}
inline void EntryPartitionReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cli.EntryPartitionReq.id)
}

// -------------------------------------------------------------------

// EntryPartitionRsp

// required string ip = 1;
inline bool EntryPartitionRsp::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntryPartitionRsp::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntryPartitionRsp::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntryPartitionRsp::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& EntryPartitionRsp::ip() const {
  // @@protoc_insertion_point(field_get:cli.EntryPartitionRsp.ip)
  return *ip_;
}
inline void EntryPartitionRsp::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:cli.EntryPartitionRsp.ip)
}
inline void EntryPartitionRsp::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:cli.EntryPartitionRsp.ip)
}
inline void EntryPartitionRsp::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cli.EntryPartitionRsp.ip)
}
inline ::std::string* EntryPartitionRsp::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cli.EntryPartitionRsp.ip)
  return ip_;
}
inline ::std::string* EntryPartitionRsp::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EntryPartitionRsp::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cli.EntryPartitionRsp.ip)
}

// required uint32 port = 2;
inline bool EntryPartitionRsp::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntryPartitionRsp::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntryPartitionRsp::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntryPartitionRsp::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 EntryPartitionRsp::port() const {
  // @@protoc_insertion_point(field_get:cli.EntryPartitionRsp.port)
  return port_;
}
inline void EntryPartitionRsp::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:cli.EntryPartitionRsp.port)
}

// required uint64 token = 3;
inline bool EntryPartitionRsp::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntryPartitionRsp::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntryPartitionRsp::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntryPartitionRsp::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 EntryPartitionRsp::token() const {
  // @@protoc_insertion_point(field_get:cli.EntryPartitionRsp.token)
  return token_;
}
inline void EntryPartitionRsp::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
  // @@protoc_insertion_point(field_set:cli.EntryPartitionRsp.token)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cli

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cli::QueryPartitionRsp_StateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cli::QueryPartitionRsp_StateType>() {
  return ::cli::QueryPartitionRsp_StateType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fclient_5flogin_2eproto__INCLUDED
